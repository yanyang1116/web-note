'use strict';
const fs = require('fs');
const chalk = require('react-dev-utils/chalk');
const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
const clearConsole = require('react-dev-utils/clearConsole');
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');
const {
	choosePort,
	createCompiler,
	prepareProxy,
	prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils');
const openBrowser = require('react-dev-utils/openBrowser');
const { appRootPathResolve } = require('./utils/pathResolve');
const createDevServerConfig = require('./webpack.devServer.config');

/**
 * Makes the script crash on unhandled rejections instead of silently
 * ignoring them. In the future, promise rejections that are not handled will
 * terminate the Node.js process with a non-zero exit code.
 */
process.on('unhandledRejection', (err) => {
	throw err;
});

// Warn and crash if required files are missing
if (
	!checkRequiredFiles([
		appRootPathResolve('./index.html'),
		appRootPathResolve('./src/index.tsx'),
	])
) {
	process.exit(1);
}

// 检测 stdout 是否正在传递
const isInteractive = process.stdout.isTTY;
// Tools like Cloud9 rely on this.
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || '0.0.0.0';

if (process.env.HOST) {
	// 一般这个不应该有值，抛出告警
	console.log(
		chalk.cyan(
			`Attempting to bind to HOST environment variable: ${chalk.yellow(
				chalk.bold(process.env.HOST)
			)}`
		)
	);
	console.log(
		`If this was unintentional, check that you haven't mistakenly set it in your shell.`
	);
	console.log(
		`Learn more here: ${chalk.yellow('https://cra.link/advanced-config')}`
	);
}

// We require that you explicitly set browsers and do not fall back to
// browserslist defaults.
const { checkBrowsers } = require('react-dev-utils/browsersHelper');
checkBrowsers(appRootPathResolve('./'), isInteractive)
	.then(() => {
		// We attempt to use the default port but if it is busy, we offer the user to
		// run on a different port. `choosePort()` Promise resolves to the next free port.
		return choosePort(HOST, DEFAULT_PORT);
	})
	.then((port) => {
		if (port == null) {
			throw new Error('We have not found a port.');
		}

		/**
		 * TODO
		 * https 方式，可以之后调试一下
		 */
		const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';

		const appName = require(appRootPathResolve('./package.json')).name;

		const useTypeScript = fs.existsSync(
			appRootPathResolve('./tsconfig.json')
		);
		const useYarn = fs.existsSync(appRootPathResolve('./yarn.lock'));

		const urls = prepareUrls(protocol, HOST, port);

		// Create a webpack compiler that is configured with custom messages.
		const compiler = createCompiler({
			appName,
			config: require('./webpack.base.config'),
			urls,
			useYarn,
			useTypeScript,
			webpack,
		});

		/**
		 * Load proxy config，
		 * TODO 代理以后可以看看，暂时不需要
		 */
		// const proxySetting = require(paths.appPackageJson).proxy;
		// const proxyConfig = prepareProxy(
		// 	proxySetting,
		// 	paths.appPublic,
		// 	paths.publicUrlOrPath
		// );
		// Serve webpack assets generated by the compiler over a web server.
		const proxyConfig = undefined;
		const serverConfig = {
			...createDevServerConfig(proxyConfig, urls.lanUrlForConfig),
			host: HOST,
			port,
		};
		const devServer = new WebpackDevServer(serverConfig, compiler);

		// Launch WebpackDevServer.
		devServer.startCallback(() => {
			if (isInteractive) {
				// 保留日志过程，会更好一些
				// clearConsole();
			}

			console.log(chalk.cyan('Starting the development server...\n'));
			openBrowser(urls.localUrlForBrowser);
		});

		['SIGINT', 'SIGTERM'].forEach(function (sig) {
			process.on(sig, function () {
				devServer.close();
				process.exit();
			});
		});

		if (process.env.CI !== 'true') {
			// Gracefully exit when stdin ends
			process.stdin.on('end', function () {
				devServer.close();
				process.exit();
			});
		}
	})
	.catch((err) => {
		if (err && err.message) {
			console.log(err.message);
		}
		process.exit(1);
	});
